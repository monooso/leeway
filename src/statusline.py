"""Claude Code statusline integration."""

import json
from pathlib import Path

from config import APP_ID


class CorruptSettingsError(Exception):
    """Raised when settings.json exists but contains invalid JSON."""

STATUSLINE_SCRIPT_NAME = "statusline-command.sh"

CLAUDE_DIR = Path.home() / ".claude"
DEFAULT_SETTINGS_PATH = CLAUDE_DIR / "settings.json"
DEFAULT_SCRIPT_PATH = CLAUDE_DIR / STATUSLINE_SCRIPT_NAME


def generate_statusline_script() -> str:
    """Generate the bash statusline script content.

    This script is invoked by Claude Code to display usage info in the
    terminal status line.  It reads the OAuth token from
    ~/.claude/.credentials.json, fetches the usage endpoint with curl,
    and formats a colour-coded output string.
    """
    return r"""#!/bin/bash
# Claude Usage statusline — generated by claude-usage-gnome
# Reads OAuth credentials, fetches usage, displays colour-coded status.

CRED_FILE="$HOME/.claude/.credentials.json"

# Read stdin (Claude Code passes context as JSON on stdin)
input=$(cat)
current_dir_path=$(echo "$input" | grep -o '"current_dir":"[^"]*"' | sed 's/"current_dir":"//;s/"$//')
current_dir=$(basename "$current_dir_path")

BLUE=$'\033[0;34m'
GREEN=$'\033[0;32m'
GRAY=$'\033[0;90m'
YELLOW=$'\033[0;33m'
RESET=$'\033[0m'

# 10-level gradient: dark green → deep red
LEVEL_1=$'\033[38;5;22m'   # dark green
LEVEL_2=$'\033[38;5;28m'   # soft green
LEVEL_3=$'\033[38;5;34m'   # medium green
LEVEL_4=$'\033[38;5;100m'  # green-yellowish dark
LEVEL_5=$'\033[38;5;142m'  # olive/yellow-green dark
LEVEL_6=$'\033[38;5;178m'  # muted yellow
LEVEL_7=$'\033[38;5;172m'  # muted yellow-orange
LEVEL_8=$'\033[38;5;166m'  # darker orange
LEVEL_9=$'\033[38;5;160m'  # dark red
LEVEL_10=$'\033[38;5;124m' # deep red

# --- Directory ---
dir_text="${BLUE}${current_dir}${RESET}"

# --- Git branch ---
branch_text=""
if git rev-parse --git-dir > /dev/null 2>&1; then
    branch=$(git branch --show-current 2>/dev/null)
    [ -n "$branch" ] && branch_text="${GREEN}⎇ ${branch}${RESET}"
fi

# --- Usage ---
usage_text=""

if [ -f "$CRED_FILE" ]; then
    # Extract access token by piping the file to python3 via stdin
    token=$(/usr/bin/python3 -c "
import json, sys
try:
    d = json.load(sys.stdin)
    print(d['claudeAiOauth']['accessToken'])
except Exception:
    sys.exit(1)
" < "$CRED_FILE" 2>/dev/null)

    if [ -n "$token" ]; then
        response=$(curl -s --max-time 5 \
            -H "Authorization: Bearer $token" \
            -H "Content-Type: application/json" \
            -H "User-Agent: """ + APP_ID + r"""" \
            -H "anthropic-beta: oauth-2025-04-20" \
            "https://api.anthropic.com/api/oauth/usage" 2>/dev/null)

        if [ -n "$response" ]; then
            # Parse by piping response to python3 via stdin
            read -r utilization resets_at <<< "$(echo "$response" | /usr/bin/python3 -c "
import json, sys
try:
    d = json.load(sys.stdin)
    fh = d.get('five_hour', {})
    pct = fh.get('utilization_pct', fh.get('utilization', ''))
    resets = fh.get('resets_at', '')
    print(int(round(float(pct))) if pct != '' else '', resets)
except Exception:
    print('', '')
" 2>/dev/null)"

            if [ -n "$utilization" ]; then
                if [ "$utilization" -le 10 ]; then usage_color="$LEVEL_1"
                elif [ "$utilization" -le 20 ]; then usage_color="$LEVEL_2"
                elif [ "$utilization" -le 30 ]; then usage_color="$LEVEL_3"
                elif [ "$utilization" -le 40 ]; then usage_color="$LEVEL_4"
                elif [ "$utilization" -le 50 ]; then usage_color="$LEVEL_5"
                elif [ "$utilization" -le 60 ]; then usage_color="$LEVEL_6"
                elif [ "$utilization" -le 70 ]; then usage_color="$LEVEL_7"
                elif [ "$utilization" -le 80 ]; then usage_color="$LEVEL_8"
                elif [ "$utilization" -le 90 ]; then usage_color="$LEVEL_9"
                else usage_color="$LEVEL_10"
                fi

                # Progress bar
                if [ "$utilization" -eq 0 ]; then
                    filled_blocks=0
                elif [ "$utilization" -ge 100 ]; then
                    filled_blocks=10
                else
                    filled_blocks=$(( (utilization * 10 + 50) / 100 ))
                fi
                [ "$filled_blocks" -lt 0 ] && filled_blocks=0
                [ "$filled_blocks" -gt 10 ] && filled_blocks=10
                empty_blocks=$((10 - filled_blocks))

                progress_bar=" "
                i=0
                while [ $i -lt $filled_blocks ]; do
                    progress_bar="${progress_bar}▓"
                    i=$((i + 1))
                done
                i=0
                while [ $i -lt $empty_blocks ]; do
                    progress_bar="${progress_bar}░"
                    i=$((i + 1))
                done

                # Reset time
                reset_time_display=""
                if [ -n "$resets_at" ] && [ "$resets_at" != "null" ]; then
                    # Convert ISO 8601 to local time using date (GNU coreutils)
                    reset_time=$(date -d "$resets_at" "+%H:%M" 2>/dev/null)
                    [ -n "$reset_time" ] && reset_time_display=" → Reset: ${reset_time}"
                fi

                usage_text="${usage_color}Usage: ${utilization}%${progress_bar}${reset_time_display}${RESET}"
            else
                usage_text="${YELLOW}Usage: ~${RESET}"
            fi
        else
            usage_text="${YELLOW}Usage: ~${RESET}"
        fi
    fi
fi

# --- Assemble output ---
output=""
separator="${GRAY} │ ${RESET}"

[ -n "$dir_text" ] && output="${dir_text}"

if [ -n "$branch_text" ]; then
    [ -n "$output" ] && output="${output}${separator}"
    output="${output}${branch_text}"
fi

if [ -n "$usage_text" ]; then
    [ -n "$output" ] && output="${output}${separator}"
    output="${output}${usage_text}"
fi

printf "%s\n" "$output"
"""


def install_statusline(
    script_path: Path = DEFAULT_SCRIPT_PATH,
    settings_path: Path = DEFAULT_SETTINGS_PATH,
) -> None:
    """Install the statusline script and update Claude Code settings."""
    script_path.parent.mkdir(parents=True, exist_ok=True)
    script_path.write_text(generate_statusline_script())
    script_path.chmod(0o755)
    update_claude_code_settings(settings_path, script_path)


def uninstall_statusline(
    script_path: Path = DEFAULT_SCRIPT_PATH,
    settings_path: Path = DEFAULT_SETTINGS_PATH,
) -> None:
    """Remove the statusline script and update Claude Code settings."""
    if script_path.exists():
        script_path.unlink()
    remove_claude_code_settings(settings_path)


def update_claude_code_settings(
    settings_path: Path,
    script_path: Path,
) -> None:
    """Add or update the statusLine entry in Claude Code settings.json."""
    settings: dict = {}
    if settings_path.exists():
        try:
            settings = json.loads(settings_path.read_text())
        except (json.JSONDecodeError, ValueError) as exc:
            raise CorruptSettingsError(
                f"Cannot update {settings_path}: file contains invalid JSON"
            ) from exc

    settings["statusLine"] = {
        "type": "command",
        "command": f"bash {script_path}",
    }

    settings_path.parent.mkdir(parents=True, exist_ok=True)
    settings_path.write_text(json.dumps(settings, indent=2) + "\n")


def remove_claude_code_settings(settings_path: Path) -> None:
    """Remove the statusLine entry from Claude Code settings.json."""
    if not settings_path.exists():
        return

    try:
        settings = json.loads(settings_path.read_text())
    except (json.JSONDecodeError, ValueError):
        return

    if "statusLine" in settings:
        del settings["statusLine"]
        settings_path.write_text(json.dumps(settings, indent=2) + "\n")
